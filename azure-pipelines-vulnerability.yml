trigger:
  - master

pool:
  name: 'Default'

variables:
  node_version: '18'
  vulnerabilityEpicId: '78'
  vulnerabilityEpicTitle: 'Security & Vulnerability Management'
  system.accesstoken: $(System.AccessToken)

steps:
- checkout: self
  clean: true
  fetchDepth: 0

# Fast install with Windows optimizations - NEEDED FOR AUDIT
- script: |
    cd my-app
    echo "Installing dependencies with Windows optimizations..."
    npm config set fund false
    npm config set audit false
    npm install --no-optional --no-fund --silent
  displayName: 'npm install (Windows optimized)'

# Security audit and vulnerability check
- task: PowerShell@2
  inputs:
    targetType: 'inline'
    script: |
      Set-Location "my-app"
      $auditFile = "audit-results.txt"
      $auditJsonFile = "audit-results.json"
      $projectName = "$(Build.Repository.Name)"
      Write-Host "##[section]Running npm audit for $projectName..."
      try {
        npm audit --omit=dev --audit-level=moderate > $auditFile
        npm audit --omit=dev --audit-level=moderate --json > $auditJsonFile
        Write-Host "##[debug]Audit files created:"
        Write-Host "##[debug]  - Text: $(Test-Path $auditFile)"
        Write-Host "##[debug]  - JSON: $(Test-Path $auditJsonFile)"
      }
      finally {
        if (Test-Path $auditFile) {
          $report = Get-Content -Path $auditFile -Raw
          Write-Host "##[section]=== NPM AUDIT REPORT ==="
          Write-Host $report
          Write-Host "##[section]==========================="
          if ($LASTEXITCODE -ne 0) {
            $scanInfo = $report | Select-String "scanned.*packages" | Select-Object -First 1
            if ($scanInfo) {
              Write-Host "##vso[task.logissue type=warning]$projectName : $($scanInfo.Line)"
            }
            Write-Host "##[warning]Vulnerabilities found - will create work items"
          } else {
            Write-Host "##[section]✅ No vulnerabilities found!"
          }
        }
        $LASTEXITCODE = 0
        Write-Host "##[debug]Audit scan completed successfully"
      }
    workingDirectory: '$(Build.SourcesDirectory)'
  displayName: 'Security vulnerability scan (robust)'

# Ensure Epic exists for vulnerability tickets
- task: PowerShell@2
  inputs:
    targetType: 'inline'
    script: |
      $headers = @{
        'Authorization' = "Bearer $(System.AccessToken)"
        'Content-Type' = 'application/json-patch+json'
      }
      $org = "$(System.TeamFoundationCollectionUri)".TrimEnd('/')
      $project = [System.Uri]::EscapeDataString("$(System.TeamProject)")
      $epicId = "$(vulnerabilityEpicId)"
      $epicTitle = "$(vulnerabilityEpicTitle)"
      $epicUrl = "$org/$project/_apis/wit/workitems/$epicId" + "?api-version=6.0"
      try {
        $epic = Invoke-RestMethod -Uri $epicUrl -Method GET -Headers @{'Authorization' = "Bearer $(System.AccessToken)"}
        Write-Host "##[section]✅ Epic #$epicId already exists: $($epic.fields.'System.Title')"
      }
      catch {
        Write-Host "##[warning]Epic #$epicId not found. Creating it..."
        $epicData = @(
          @{
            op = "add"
            path = "/fields/System.Title"
            value = $epicTitle
          },
          @{
            op = "add"
            path = "/fields/System.WorkItemType"
            value = "Epic"
          },
          @{
            op = "add"
            path = "/fields/System.Description"
            value = "Epic for tracking security vulnerabilities and their fixes"
          },
          @{
            op = "add"
            path = "/fields/System.Tags"
            value = "security; vulnerability; automated"
          }
        )
        $epicJson = $epicData | ConvertTo-Json -Depth 4
        $createEpicUrl = "$org/$project/_apis/wit/workitems/`$Epic?api-version=6.0"
        try {
          $newEpic = Invoke-RestMethod -Uri $createEpicUrl -Method POST -Headers $headers -Body $epicJson
          Write-Host "##[section]✅ Created Epic #$($newEpic.id): $($newEpic.fields.'System.Title')"
          Write-Host "##vso[task.setvariable variable=vulnerabilityEpicId]$($newEpic.id)"
        }
        catch {
          Write-Host "##[error]Failed to create Epic: $($_.Exception.Message)"
          Write-Host "##[warning]Will create Bug items without Epic relationship"
        }
      }
  displayName: 'Create or verify Epic for vulnerabilities'
  continueOnError: true

# Create work items for vulnerabilities under Epic
- task: PowerShell@2
  timeoutInMinutes: 2
  inputs:
    targetType: 'filePath'
    filePath: 'scripts/Security-VulnerabilityTickets.ps1'
    arguments: >
      -EpicId "$(vulnerabilityEpicId)"
      -EpicTitle "$(vulnerabilityEpicTitle)" 
      -Organization "$(System.TeamFoundationCollectionUri)"
      -Project "$(System.TeamProject)"
      -AccessToken "$(System.AccessToken)"
      -AuditFile "my-app/audit-results.json"
      -RepositoryName "$(Build.Repository.Name)"
    workingDirectory: '$(Build.SourcesDirectory)'
  displayName: 'Create vulnerability Issue items under Epic #$(vulnerabilityEpicId)'
  continueOnError: true

# Ensure log and result files exist
- task: PowerShell@2
  inputs:
    targetType: 'inline'
    script: |
      if (-not (Test-Path "vulnerability-processing.log")) {
        "No vulnerability processing log was created." | Set-Content "vulnerability-processing.log"
      }
      if (-not (Test-Path "work-item-results.json")) {
        '{"message":"No results file was created","timestamp":"' + (Get-Date -Format "yyyy-MM-dd HH:mm:ss") + '"}' | Set-Content "work-item-results.json"
      }
      Write-Host "##[section]Files available for artifacts:"
      Get-ChildItem -Filter "*.log" | ForEach-Object { Write-Host "  - $($_.Name)" }
      Get-ChildItem -Filter "*.json" | ForEach-Object { Write-Host "  - $($_.Name)" }
  displayName: 'Ensure artifact files exist'
  condition: always()

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'vulnerability-processing.log'
    ArtifactName: 'debug-logs'
    publishLocation: 'Container'
  displayName: 'Publish vulnerability processing log'
  condition: always()

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'work-item-results.json'
    ArtifactName: 'debug-results'
    publishLocation: 'Container'
  displayName: 'Publish work item results'
  condition: always()
