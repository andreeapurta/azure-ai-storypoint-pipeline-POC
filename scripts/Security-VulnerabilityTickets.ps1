<#
.SYNOPSIS
    Creates Azure DevOps work items for npm audit vulnerabilities
.DESCRIPTION
    This script reads npm audit results and creates Issue work items under a specified Epic.
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$EpicId,
    
    [Parameter(Mandatory=$true)]
    [string]$EpicTitle,
    
    [Parameter(Mandatory=$true)]
    [string]$Organization,
    
    [Parameter(Mandatory=$true)]
    [string]$Project,
    
    [Parameter(Mandatory=$true)]
    [string]$AccessToken,
    
    [Parameter(Mandatory=$false)]
    [string]$AuditFile = "audit-results.json",
    
    [Parameter(Mandatory=$false)]
    [string]$RepositoryName = "Unknown Repository"
)

# Initialize working directory
$workingDir = Get-Location
$resultFile = Join-Path $workingDir "work-item-results.json"

. "$PSScriptRoot\functions\Write-Log.ps1"

# Start
Write-Log "Vulnerability Work Item Creator"



# Check if audit file exists
if (-not (Test-Path $AuditFile)) {
    $message = "Audit results file not found: $AuditFile"
    Write-LogAndHost $message "Yellow"
    $results.errors += $message
    
    $results | ConvertTo-Json -Depth 4 | Set-Content $resultFile
    Write-LogAndHost "No vulnerabilities to process - results saved to $resultFile" "Green"
    exit 0
}

# Read and parse audit results
try {
    $auditContent = Get-Content $AuditFile -Raw
    $audit = $auditContent | ConvertFrom-Json
    
    Write-Log "Found $($audit.metadata.vulnerabilities.total) total vulnerabilities"
}
catch {
    Write-Log "Failed to parse audit file: $($_.Exception.Message)" "ERROR"
    exit 1
}

# Check if vulnerabilities exist
if ($audit.metadata.vulnerabilities.total -eq 0) {
    Write-Log "No vulnerabilities found - all good!"
    exit 0
}

# Create headers for Azure DevOps REST API
# For GET/POST/WIQL operations
$headers = @{
    'Authorization' = "Bearer $AccessToken"
    'Content-Type' = 'application/json'
}

# For PATCH operations (creating/updating work items)
$patchHeaders = @{
    'Authorization' = "Bearer $AccessToken"
    'Content-Type' = 'application/json-patch+json'
}

# Test Epic existence first
$baseUrl = $Organization.TrimEnd('/')
$encodedProject = [System.Uri]::EscapeDataString($Project)
$epicCheckUrl = "$baseUrl/$encodedProject/_apis/wit/workitems/$EpicId" + "?api-version=6.0"

$epicExists = $false
try {
    $epicResponse = Invoke-RestMethod -Uri $epicCheckUrl -Method GET -Headers @{'Authorization' = "Bearer $AccessToken"}
    if ($epicResponse.id) {
    Write-Log "Epic #$EpicId found: $($epicResponse.fields.'System.Title')"
        $epicExists = $true
    }
}
catch {
    Write-Log "Epic #$EpicId not found - creating standalone work items" "WARN"
}

# Query existing vulnerability work items to avoid duplicates
Write-Log "Checking for existing vulnerability work items..."
$existingWorkItems = @{}

try {
    $wiqlQuery = @"
SELECT [System.Id], [System.Title]
FROM WorkItems
WHERE [System.WorkItemType] = 'Issue'
AND [System.Tags] CONTAINS 'vulnerability'
AND [System.Tags] CONTAINS 'automated'
AND [System.State] <> 'Closed'
AND [System.State] <> 'Removed'
"@

    $wiqlUrl = "$baseUrl/$encodedProject/_apis/wit/wiql?api-version=6.0"
    $wiqlPayload = @{ query = $wiqlQuery } | ConvertTo-Json
    
    $wiqlResponse = Invoke-RestMethod -Uri $wiqlUrl -Method POST -Headers $headers -Body $wiqlPayload -TimeoutSec 10
    
    if ($wiqlResponse.workItems -and $wiqlResponse.workItems.Count -gt 0) {
    Write-Log "Found $($wiqlResponse.workItems.Count) existing vulnerability work items" "WARN"
        
        # Get details for each work item to extract package names
        $workItemIds = $wiqlResponse.workItems | ForEach-Object { $_.id }
        $batchUrl = "$baseUrl/$encodedProject/_apis/wit/workitems?ids=$($workItemIds -join ',')&fields=System.Id,System.Title&api-version=6.0"
        
        $workItemDetails = Invoke-RestMethod -Uri $batchUrl -Method GET -Headers @{'Authorization' = "Bearer $AccessToken"}
        
        foreach ($workItem in $workItemDetails.value) {
            $title = $workItem.fields.'System.Title'
            # Extract package name from title pattern "Security check: PACKAGE_NAME vulnerability"
            if ($title -match "Security check: (.+?) vulnerability") {
                $packageName = $matches[1]
                $existingWorkItems[$packageName] = $workItem.id
                Write-Log "  - Existing: $packageName (Work Item #$($workItem.id))" "DEBUG"
            }
        }
    } else {
    Write-Log "No existing vulnerability work items found"
    }
}
catch {
    Write-Log "Warning: Could not query existing work items: $($_.Exception.Message)" "WARN"
    Write-Log "This might be due to service issues. Exiting to prevent delays." "WARN"
    exit 0
}

$createdCount = 0
$skippedCount = 0
$processedPackages = @()

# Process each vulnerability
foreach ($vulnProperty in $audit.vulnerabilities.PSObject.Properties) {
    $vuln = $vulnProperty.Value
    $vulnName = $vulnProperty.Name
    
    # Only process high and critical vulnerabilities that are DIRECT dependencies
    if ($vuln.severity -in @('high', 'critical') -and $vuln.isDirect -eq $true) {
        
        # Avoid duplicate work items for the same package (within this run)
        if ($processedPackages -contains $vulnName) {
            continue
        }
        
        # Check if work item already exists in Azure DevOps
        if ($existingWorkItems.ContainsKey($vulnName)) {
            Write-Log "Skipping $vulnName - Work Item #$($existingWorkItems[$vulnName]) already exists" "WARN"
            $skippedCount++
            continue
        }
        
        $processedPackages += $vulnName
        
        # Create detailed description with name, severity, and URL
        $description = "Name: $vulnName`r`n"
        $description += "Severity: $($vuln.severity.ToUpper())`r`n"
        
        # Extract URLs from vulnerability details
        $urls = @()
        
        if ($vuln.via -and $vuln.via.Count -gt 0) {
            foreach ($viaItem in $vuln.via) {
                if ($viaItem.url) {
                    $urls += $viaItem.url
                }
            }
        }
        
        # Add URLs to description
        if ($urls.Count -gt 0) {
            $description += "URL: $($urls[0])`r`n"
            if ($urls.Count -gt 1) {
                for ($i = 1; $i -lt $urls.Count; $i++) {
                    $description += "Additional URL: $($urls[$i])`r`n"
                }
            }
        } else {
            $description += "URL: Not available`r`n"
        }
        
        # Add additional context
        $description += "`r`nRepository: $RepositoryName`r`n"
        $description += "Version Range: $($vuln.range)`r`n"
        $description += "Direct Dependency: $($vuln.isDirect)"
        
        # Create work item data
        $title = "Security check: $vulnName vulnerability"
        
    Write-Log "Creating work item: $title"
        
        # Set priority based on severity
        $priority = if ($vuln.severity -eq 'critical') { 1 } else { 2 }
        
        # Create work item JSON payload
        $workItemData = @(
            @{
                op = "add"
                path = "/fields/System.Title"
                value = $title
            },
            @{
                op = "add"
                path = "/fields/System.Description"
                value = $description
            },
            @{
                op = "add"
                path = "/fields/System.WorkItemType"
                value = "Issue"
            },
            @{
                op = "add"
                path = "/fields/Microsoft.VSTS.Common.Priority"
                value = $priority
            },
            @{
                op = "add"
                path = "/fields/System.Tags"
                value = "vulnerability; security; $($vuln.severity); automated"
            }
        )
        
        # Only add Epic relationship if Epic exists
        if ($epicExists) {
            $workItemData += @{
                op = "add"
                path = "/relations/-"
                value = @{
                    rel = "System.LinkTypes.Hierarchy-Reverse"
                    url = "$($Organization.TrimEnd('/'))/_apis/wit/workItems/$EpicId"
                }
            }
        }
        
        $jsonPayload = $workItemData | ConvertTo-Json -Depth 4
        

        
        # API endpoint for creating work items
        $createUrl = "$baseUrl/$encodedProject/_apis/wit/workitems/`$Issue?api-version=6.0"
        
        try {
            $response = Invoke-RestMethod -Uri $createUrl -Method POST -Headers $patchHeaders -Body $jsonPayload
            
            if ($response.id) {
                $createdCount++
                Write-Log "Created Issue #$($response.id): $vulnName"
            } else {
                Write-Log "ERROR: Failed to create work item: $title" "ERROR"
            }
        }
        catch {
            Write-Log "ERROR - Error creating work item for $vulnName - $($_.Exception.Message)" "ERROR"
        }
    }
}

# Summary
Write-Log ""
Write-Log "=== VULNERABILITY PROCESSING SUMMARY ==="
Write-Log "Created: $createdCount new work items"
Write-Log "Skipped: $skippedCount existing work items" "WARN"
Write-Log "Total vulnerabilities processed: $($createdCount + $skippedCount)"

if ($createdCount -eq 0 -and $skippedCount -eq 0) {
    Write-Log "No direct high/critical vulnerabilities found"
}

exit 0